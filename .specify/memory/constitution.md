<!--
Sync Impact Report:
- Version change: none → 1.0.0
- Modified principles: All 7 principles created from scratch
- Added sections: All sections created from scratch
- Removed sections: None
- Templates requiring updates:
  ✅ .specify/templates/plan-template.md - Constitution Check aligns with test-first and spec-driven principles
  ✅ .specify/templates/spec-template.md - User scenarios and requirements align with MVP-first approach
  ✅ .specify/templates/tasks-template.md - Task organization supports user story independence
- Follow-up TODOs: None
-->

# Evolution of Todo Constitution

## Core Principles

### I. Spec-Driven Development (NON-NEGOTIABLE)

Every feature MUST follow strict spec-driven development workflow:
1. Specification MUST be written and approved before any implementation
2. Plan MUST be generated from specification
3. Tasks MUST be broken down from plan
4. Implementation MUST be generated by Claude Code
5. Direct manual coding is FORBIDDEN except for spec refinement
6. Iteration happens by refining the spec until Claude generates correct output

**Rationale**: This hackathon judges the process, prompts, and iterations. The role shifts from "syntax writer" to "system architect." Spec-driven development enables AI agents to generate implementation accurately.

### II. Test-First (NON-NEGOTIABLE)

TDD is mandatory for all development:
1. Tests MUST be written before implementation
2. Tests MUST fail initially (Red phase)
3. Implementation MUST make tests pass (Green phase)
4. Refactoring MUST preserve passing tests (Refactor phase)
5. Red-Green-Refactor cycle is strictly enforced

**Rationale**: Test-First ensures quality, validates requirements through executable specifications, and enables confident refactoring across the evolution from CLI to cloud-native.

### III. Incremental Evolution

Application MUST evolve through defined phases, each independently deployable:
1. Phase I: In-Memory Python Console App (Basic features only)
2. Phase II: Full-Stack Web Application (Intermediate features)
3. Phase III: AI-Powered Todo Chatbot (Advanced AI features)
4. Phase IV: Local Kubernetes Deployment (Container orchestration)
5. Phase V: Advanced Cloud Deployment (Event-driven architecture)

Each phase MUST build on previous phases while maintaining backward compatibility where possible.

**Rationale**: Demonstrates real-world software evolution, validates architectural decisions incrementally, and ensures each phase delivers working value.

### IV. Reusable Intelligence

Code MUST leverage reusable intelligence patterns:
1. Agent Skills MUST be created for repeatable workflows
2. Subagents MUST be developed for complex, multi-step tasks
3. Cloud-Native Blueprints MUST be created for deployment patterns
4. Intelligence artifacts MUST be versioned and documented
5. Reusable components MUST be tested independently

**Rationale**: Reusable intelligence accelerates development, ensures consistency, and demonstrates mastery of the Agentic Dev Stack.

### V. Clean Code Architecture

All code MUST follow clean code principles:
1. Clear separation of concerns: models, services, CLI/UI, controllers
2. Single Responsibility Principle: each module/function has one reason to change
3. Dependency Inversion: depend on abstractions, not concretions
4. Clear project structure with dedicated /src folder
5. Readable, self-documenting code with necessary comments only for complex logic

**Rationale**: Clean code is essential for maintainability, testing, and evolution across the 5 phases from CLI to distributed systems.

### VI. Cloud-Native Standards

All deployment artifacts MUST follow cloud-native best practices:
1. Containerization: EVERYTHING MUST run in containers (Docker)
2. Declarative configuration: Use Kubernetes manifests and Helm charts
3. Immutable infrastructure: No manual server configuration
4. Observability: Structured logs, metrics, and traces (AIOps with kubectl-ai, kagent)
5. Infrastructure as Code: All deployment artifacts versioned in repository

**Rationale**: Cloud-native standards ensure scalability, portability, and operational excellence for production deployments.

### VII. AI-Native Integration

Application MUST leverage AI capabilities progressively:
1. Phase III+: Conversational interface via OpenAI Agents SDK and MCP SDK
2. Natural language task management (e.g., "Reschedule my morning meetings to 2 PM")
3. AI-assisted operations (kubectl-ai, kagent for Kubernetes management)
4. Context-aware task prioritization and scheduling
5. Multi-language support (bonus: Urdu support for chatbot)

**Rationale**: AI-native integration demonstrates mastery of modern AI tooling and creates differentiated user experiences.

## Technology Constraints

### Phase-Specific Requirements

**Phase I (In-Memory Console)**
- Python 3.13+ required
- UV for dependency management
- Claude Code for implementation
- Spec-Kit Plus for spec-driven workflow
- In-memory storage (no persistence)

**Phase II (Full-Stack Web)**
- Next.js for frontend (TypeScript)
- FastAPI for backend API
- SQLModel for database models
- Neon Serverless PostgreSQL for persistence
- Proper API contracts and documentation

**Phase III (AI Chatbot)**
- OpenAI ChatKit for conversation interface
- OpenAI Agents SDK for agent orchestration
- Official MCP SDK for model context protocol
- Natural language understanding for todo operations

**Phase IV (Local K8s Deployment)**
- Docker for containerization
- Minikube for local Kubernetes cluster
- Helm Charts for deployment packaging
- kubectl-ai and kagent for AIOps
- CI/CD pipelines (bonus)

**Phase V (Advanced Cloud)**
- Kafka for event streaming
- Dapr for distributed application runtime
- DigitalOcean Kubernetes (DOKS) for production deployment
- Advanced observability and monitoring

### Cross-Cutting Requirements

- All phases MUST use Claude Code and Spec-Kit Plus
- All phases MUST generate spec, plan, and tasks artifacts
- All phases MUST maintain clean code architecture
- Windows users MUST use WSL 2 for development

## Development Workflow

### Spec-Driven Lifecycle

1. **Spec Phase** (/sp.specify)
   - User provides feature description
   - Generate spec with user stories (prioritized P1, P2, P3)
   - Define acceptance scenarios with Given-When-Then format
   - Each user story MUST be independently testable

2. **Plan Phase** (/sp.plan)
   - Generate architectural plan from spec
   - Define data models, contracts, and APIs
   - Perform Constitution Check
   - Create project structure documentation

3. **Tasks Phase** (/sp.tasks)
   - Break down plan into actionable tasks
   - Organize by user story for incremental delivery
   - Define dependencies and parallelization opportunities
   - Generate GitHub issues (bonus: /sp.taskstoissues)

4. **Implementation Phase** (/sp.implement)
   - Execute tasks via Claude Code
   - NO manual coding allowed
   - Generate implementation from spec refinement
   - Validate against acceptance criteria

5. **Verification Phase**
   - Run tests and validate quickstart
   - Create ADRs for significant decisions
   - Generate PHR records for all prompts
   - Deploy and demo functionality

### Iteration Protocol

If Claude generates incorrect code:
1. Review the spec for missing or unclear requirements
2. Refine the spec with more specific details
3. Re-run implementation
4. Repeat until correct output is generated
5. Document all iterations in PHR records

### Quality Gates

**Before Starting Implementation**:
- [ ] Spec approved with complete user stories
- [ ] Plan generated with Constitution Check passed
- [ ] Tasks defined with dependencies mapped
- [ ] All placeholders resolved

**Before Marking Story Complete**:
- [ ] All tests pass (if tests requested)
- [ ] Quickstart validation successful
- [ ] Independent test verified for user story
- [ ] Code review (if applicable)

**Before Phase Completion**:
- [ ] All priority user stories implemented
- [ ] Cross-cutting concerns addressed
- [ ] Documentation updated
- [ ] Deployment verified (if applicable)

## Artifact Requirements

### Mandatory Deliverables per Phase

**Repository Structure**:
```
.github/               # GitHub workflows (bonus)
.specify/              # SpecKit Plus framework
├── memory/
│   └── constitution.md # This file
├── templates/         # Spec templates
└── scripts/           # Setup/utilities
history/
├── prompts/           # PHR records
│   ├── constitution/  # Constitution updates
│   ├── <feature>/     # Feature-specific PHRs
│   └── general/      # General PHRs
└── adr/               # Architecture Decision Records
specs/                 # Feature specifications
├── <feature>/
│   ├── spec.md
│   ├── plan.md
│   ├── tasks.md
│   ├── research.md
│   ├── data-model.md
│   ├── contracts/
│   └── quickstart.md
src/                   # Source code (phase-dependent)
├── models/
├── services/
├── cli/               # Phase I
├── api/               # Phase II+
└── web/               # Phase II+
tests/                 # Test suites
├── contract/
├── integration/
└── unit/
README.md              # Setup and usage instructions
CLAUDE.md              # Claude Code instructions
pyproject.toml         # Phase I+ Python config
Dockerfile             # Phase III+
helm/                  # Phase IV+ Helm charts
```

**Spec Artifacts**:
- spec.md with prioritized user stories (P1, P2, P3)
- plan.md with architecture decisions
- tasks.md with implementation tasks
- research.md for technical exploration (if applicable)
- data-model.md for entity definitions (if applicable)
- contracts/ for API contracts (if applicable)
- quickstart.md for setup instructions

**History Artifacts**:
- PHR records for EVERY user prompt
- ADRs for significant architectural decisions
- Constitution version history

### Bonus Deliverables

- Reusable Intelligence artifacts (Agent Skills, Subagents)
- Cloud-Native Blueprints (Agent Skills for deployment)
- Multi-language support (Urdu for chatbot)
- Voice commands for todo management
- CI/CD pipeline configurations
- Comprehensive integration tests

## Governance

### Amendment Process

This Constitution is the authoritative source for all development decisions.

**Amendment Requirements**:
1. Amendments MUST be documented with rationale
2. Version MUST be incremented per semantic versioning rules
3. Impact MUST be assessed on existing artifacts
4. Team (or developer for individual project) MUST approve
5. Propagation MUST be verified across all dependent artifacts

**Versioning Policy**:
- MAJOR (X.0.0): Backward incompatible governance or principle removals
- MINOR (0.X.0): New principle/section added or materially expanded
- PATCH (0.0.X): Clarifications, wording fixes, non-semantic refinements

### Compliance Review

**For Every Spec Created**:
- Verify Constitution alignment in plan.md "Constitution Check" section
- Flag any violations with Complexity Tracking justification
- No violation may proceed without explicit rationale

**For Every Code Review**:
- Verify spec-driven workflow was followed
- Check that implementation was generated, not manually written
- Validate clean code principles adherence
- Confirm tests were written before implementation (if applicable)

**For Every Phase Completion**:
- Review all PHR records for process quality
- Assess ADR coverage for architectural decisions
- Verify all mandatory deliverables present
- Validate deployment and functionality

### Enforcement

**Claude Code Instructions (CLAUDE.md)**:
- Constitution supersedes all other guidance
- All agents MUST reference constitution for principle decisions
- SpecKit Plus commands MUST enforce constitutional constraints
- Violations MUST be flagged and require explicit justification

**Human Oversight**:
- Developer acts as Product Architect, not syntax writer
- Review process focuses on spec quality, not code style
- Judgment required for: ambiguous requirements, unforeseen dependencies, architectural tradeoffs
- Complexity must be justified when violating constitutional principles

### Runtime Guidance

For implementation guidance, reference:
- Constitution: `.specify/memory/constitution.md` (this file)
- Project Instructions: `CLAUDE.md` (in repo root)
- Spec Templates: `.specify/templates/` (spec, plan, tasks)
- Phase-specific guidelines: `specs/<feature>/quickstart.md`

**Version**: 1.0.0 | **Ratified**: 2025-12-28 | **Last Amended**: 2025-12-28
